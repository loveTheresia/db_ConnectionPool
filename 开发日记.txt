------2025.6.4------
    发现引入json文件后vscode的语法检查不工作了，冥思苦想找不到原因，怀疑是使用的json.hpp头文件太长，
非标准语法太多，把其他文件也挤掉了
    最后发现linux有更方便的方法：安装依赖库文件，将头文件目录加入c_cpp_properties.json中，然后就可以直接
用json.h文件了


------2025.6.6------
    今天学习了多线程的新知识，或者说旧知识，以前一直搞不懂的东西，过了几个星期反而明朗了起来
在这里必须重新说明一下互斥锁的原理：一般建议使用unique_lock<mutex> lock(m_mutex)的方式以保证mutex变量的正确使用
而这个锁会被系统智能管理，同一时间只有一个线程可以持有锁并进行操作（哪怕在不同函数中上锁，没抢到的败犬只能等在lock这里了）
更神奇的是，unique_lock会记录锁与各个线程的关系，实现超越单纯上下文的线程管理
条件变量其实不是变量，而是一个“通知”机制，特殊之处在于可以操控线程，
条件变量的作用: 1、调用wait函数让所有线程执行到此处就阻塞
               2、调用notify_all/one让阻塞在变量的线程都唤醒，唤醒后unique_lock会决定如何竞争锁，竞争到锁的线程可以
                    跳出wait函数，其余线程继续阻塞（你们配合挺默契的啊）
                3、必须指出很关键的一点，就是线程被条件变量唤醒后是不会立刻竞争的，必须等锁被unique_lock重新释放后，
                    再被安排重新竞争，所以条件变量内部有等待队列、锁池等复杂结构

------2025.6.8------
    进度又拖慢了，今天引入了cmake来编译文件，结果json又识别不了了，现在还在钻研中，然后将项目上传到了github（虽然没有实际作用，但是为了仪式感哈哈哈哈）


------2025.6.9------
    JSON的问题解决了，原来还要链接jsoncpp_lib库文件才行;
    但新的问题又出现了：链接到库文件后语法确实没报错了，但cmake又报错找不到对应库文件（这不是自己打自己脸吗）
查了一些资料，才直到这是CMake的自动适配机制：因为不同平台对库文件的命名规则不同，所以CMake不用命名来查找库
转而使用逻辑库名，再结合CMake根据操作系统自动添加前缀和后缀，实现了项目的可移植，而我们可以通过